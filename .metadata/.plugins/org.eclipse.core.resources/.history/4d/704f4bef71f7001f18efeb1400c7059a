package com.tasks.pptReaderProject.service.impl;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.poi.xslf.usermodel.XMLSlideShow;
import org.apache.poi.xslf.usermodel.XSLFGroupShape;
import org.apache.poi.xslf.usermodel.XSLFShape;
import org.apache.poi.xslf.usermodel.XSLFSlide;
import org.springframework.web.multipart.MultipartFile;

import com.tasks.pptReaderProject.service.pptUploadService;

public class pptUploadServiceImpl implements pptUploadService {

	@Override
	public Map<String, Object> parsePpt(MultipartFile file) {
		Map<String, Object> response = new HashMap<>();

        try (InputStream is = file.getInputStream(); XMLSlideShow ppt = new XMLSlideShow(is)) {
            List<Map<String, Object>> slidesData = new ArrayList<>();

            for (XSLFSlide slide : ppt.getSlides()) {
                List<Map<String, Object>> shapesList = new ArrayList<>();

                for (XSLFShape shape : slide.getShapes()) {
                    Map<String, Object> shapeData = extractShapeData(shape);
                    shapesList.add(shapeData);
                }

                slidesData.add(Map.of(
                        "slide_number", slide.getSlideNumber(),
                        "shapes", shapesList
                ));
            }

            response.put("slides", slidesData);
        } catch (Exception e) {
            response.put("error", "Failed to process PPT file");
        }

        return response;
    }

    private Map<String, Object> extractShapeData(XSLFShape shape) {
        Map<String, Object> shapeData = new HashMap<>();
        shapeData.put("shape_name", shape.getShapeName());

        if (shape instanceof XSLFGroupShape groupShape) {
            List<Map<String, Object>> innerShapes = new ArrayList<>();
            for (XSLFShape innerShape : groupShape.getShapes()) {
                innerShapes.add(extractShapeData(innerShape));
            }
            shapeData.put("inner_shapes", innerShapes);
        }

        // Extract SVG path numbers without Batik
        List<String> svgPaths = SvgPathExtractor.extractSvgPathNumbers(shape);
        if (!svgPaths.isEmpty()) {
            shapeData.put("svg_paths", svgPaths);
        }

        return shapeData;
    }
}
